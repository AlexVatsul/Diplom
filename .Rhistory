plot(1:20)
install.packages("languageserver")
q()
plot(1:30)
library(quantmod)
universe <- c('AAPL', 'GOOGL', 'TSLA', 'PFE', 'CSCO', 'BIAI', 'AUPH', 'V')
x <- getSymbols(Symbols = universe[i], from='2016-01-01', auto.assign = FALSE)
i = 2
x <- getSymbols(Symbols = universe[i], from='2016-01-01', auto.assign = FALSE)
x
x[,4]
plot(x[,4])
universe <- c('AAPL', 'GOOGL', 'TSLA', 'PFE', 'CSCO', 'BIAI', 'AUPH', 'V', 'GAZP')
i = 9
x <- getSymbols(Symbols = universe[i], from='2016-01-01', auto.assign = FALSE)
universe <- c('AAPL', 'GOOGL', 'TSLA', 'PFE', 'CSCO', 'BIAI', 'AUPH', 'V')
i = 2
x <- getSymbols(Symbols = universe[i], from='2016-01-01', auto.assign = FALSE)
plot(x[,4])
i = 1
x <- getSymbols(Symbols = universe[i], from='2016-01-01', auto.assign = FALSE)
plot(x[,4])
plot(dailyReturn(x[,4]))
for(i in 1:8)
{
price <- getSymbols(Symbols = universe[i], from='2016-01-01', auto.assign = FALSE)
ret <- dailyReturn(price[,4])
if(i == 1) universe_ret <- ret
if(i != 1) universe_ret <- merge(universe_ret, ret)
}
for(i in 1:7)
{
price <- getSymbols(Symbols = universe[i], from='2016-01-01', auto.assign = FALSE)
ret <- dailyReturn(price[,4])
if(i == 1) universe_ret <- ret
if(i != 1) universe_ret <- merge(universe_ret, ret)
}
universe <- c('AAPL', 'GOOGL', 'TSLA', 'PFE', 'CSCO', 'AUPH', 'V')
for(i in 1:7)
{
price <- getSymbols(Symbols = universe[i], from='2016-01-01', auto.assign = FALSE)
ret <- dailyReturn(price[,4])
if(i == 1) universe_ret <- ret
if(i != 1) universe_ret <- merge(universe_ret, ret)
}
head(universe_ret)
colnames(universe_ret) <- universe
head(universe_ret)
w <- rep(1/7, 7)
w
xts(rowSums(universe_ret*w), order.by = as.Date(universe_ret))
xts(rowSums(universe_ret * w), order.by = index(universe_ret))
head(universe_ret)
str(universe_ret)
universe_ret$Date
universe_ret$index
xts(rowSums(universe_ret * w), order.by = index(universe_ret))
xts(rowSums(universe_ret * w), order.by = index(universe_ret))
portfolio <- xts(rowSums(universe_ret * w), order.by = index(universe_ret))
str(portfolio)
colnames(portfolio) <- "Value"
head(portfolio)
portfolio['Value']
portfolio["Value"]
portfolio$Value
portfolio[,"Value"]
apply(universe_ret, 2, mean)
apply(universe_ret, 2, std)
apply(universe_ret, 2, sd)
100*250*apply(universe_ret, 2, mean)
100*sqrt(250)*apply(universe_ret, 2, sd)
stocks_ret <- 100*250*apply(universe_ret, 2, mean)
stocks_risk <- 100*sqrt(250)*apply(universe_ret, 2, sd)
plot(stocks_risk, stocks_ret)
plot(stocks_risk, stocks_ret, xlab = 'Risk', ylab = 'Return', pch=16)
text(stocks_risk, stocks_ret, labels = universe)
grid()
text(stocks_risk, stocks_ret, labels = universe, pos = 2)
plot(stocks_risk, stocks_ret, xlab = 'Risk', ylab = 'Return', pch=16)
text(stocks_risk, stocks_ret, labels = universe, pos = 2)
text(stocks_risk, stocks_ret, labels = universe, pos = -2)
plot(stocks_risk, stocks_ret, xlab = 'Risk', ylab = 'Return', pch=16)
text(stocks_risk, stocks_ret, labels = universe, pos = 2)
grid()
text(stocks_risk, stocks_ret, labels = universe, pos = c(2,1))
plot(stocks_risk, stocks_ret, xlab = 'Risk', ylab = 'Return', pch=16)
text(stocks_risk, stocks_ret, labels = universe, pos = c(2,1))
grid()
plot(stocks_risk, stocks_ret, xlab = 'Risk', ylab = 'Return', pch=16,xlim = c(20,100))
text(stocks_risk, stocks_ret, labels = universe, pos = c(2,1))
grid()
points(100*sqrt(250)*apply(portfolio, 2, sd), 100*250*apply(portfolio, 2, mean))
points(100*sqrt(250)*apply(portfolio, 2, sd), 100*250*apply(portfolio, 2, mean), col='red', pch=17)
plot(stocks_risk, stocks_ret, xlab = 'Risk', ylab = 'Return', pch=16,xlim = c(20,100))
text(stocks_risk, stocks_ret, labels = universe, pos = c(2,1))
grid()
points(100*sqrt(250)*apply(portfolio, 2, sd), 100*250*apply(portfolio, 2, mean), col='red', pch=17)
library(PortfolioAnalytics)
install.packages("PortfolioAnalytics")
library(PortfolioAnalytics)
pf <- portfolio.spec(universe)
pf
pf <- portfolio.spec(universe)
pf <- add.constraint(portfolio = pf, type = "full_investment")
pf <- add.constraint(portfolio = pf, type = "long_only")
pf <- add.constraint(portfolio = pf, type = "box", min=0.05, max=0.25)
portf.minStdDev <- add.objective(pf, type="risk", name="StdDev")
opt_portf <- optimize.portfolio(universe_ret, portf.minStdDev)
install.packages("Deoptim")
install.packages("DEoptim")
library(DEoptim)
pf <- portfolio.spec(universe)
pf <- add.constraint(portfolio = pf, type = "full_investment")
pf <- add.constraint(portfolio = pf, type = "long_only")
pf <- add.constraint(portfolio = pf, type = "box", min=0.05, max=0.25)
portf.minStdDev <- add.objective(pf, type="risk", name="StdDev")
opt_portf <- optimize.portfolio(universe_ret, portf.minStdDev)
opt_portf$weights
w_opt <- opt_portf$weights
portfolio_opt <- xts(rowSums(universe_ret * w), order.by = index(universe_ret))
points(100*sqrt(250)*apply(portfolio_opt, 2, sd), 100*250*apply(portfolio_opt, 2, mean), col='blue', pch=17)
library(PerformanceAnalytics)
charts.PerformanceSummary(portfolio_opt)
getSymbols('SPY')
compare <- merge(portfolio_opt, dailyReturn(SPY[,4]))
charts.PerformanceSummary(compare)
SharpeRatio.annualized(compare)
?ugarchspec
library(rugarch)
?ugarchspec
setwd("E:/МЕХМАТ обучение/4 семестр/очка/НИР/Diplom")
# # Control + Shift + c - комментировать
# install.packages("ggthemes")
# install.packages("gridExtra")
# Загружаем необходимые библиотеки
library(tidyverse)
library(ggthemes)
library(forecast)
library(tseries)
library(gridExtra)
library(rugarch)
library(xts)
library(zoo)
data <- read.csv("portfolio_2015_2025.csv")
colSums(is.na(data))  # количество NA в каждом столбце
head(data)
# Преобразуем строки в даты
data$X <- as.Date(data$X, format = "%Y-%m-%d")
data_xts <- xts(data$ret_GAZP, order.by = data$X)
subset_xts <- window(data_xts, start = as.Date("2020-01-01"),
end = as.Date("2022-02-24"))
length(subset_xts)
rets = subset_xts
p1 = qplot(x = 1:length(rets) , y = rets , geom = 'line') + geom_line(color = 'darkblue') +
geom_hline(yintercept = mean(rets) , color = 'red' , size = 1) +
labs(x = '' , y = 'Daily Returns')
p2 = qplot(rets , geom = 'density') + coord_flip() + geom_vline(xintercept = mean(rets) , color = 'red' , size = 1) +
geom_density(fill = 'lightblue' , alpha = 0.4) + labs(x = '')
grid.arrange(p1 , p2 , ncol = 2)
# GARCH(1,1)
tsdisplay(ar.res^2 , main = 'Squared Residuals')
# Оценка среднего через ARMA
model.arima = auto.arima(rets , max.order = c(3 , 0 ,3) , stationary = TRUE , trace = T , ic = 'aicc')
model.arima
model.arima$residuals %>% ggtsdisplay(plot.type = 'hist' , lag.max = 14)
ar.res = model.arima$residuals
Box.test(model.arima$residuals , lag = 14 , fitdf = 2 , type = 'Ljung-Box')
# GARCH(1,1)
tsdisplay(ar.res^2 , main = 'Squared Residuals')
garch_spec = ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(0, 0)))
fit_garch = ugarchfit(spec = garch_spec, data = ar.res)
fit_garch
# Получим сигмы
sigma_vals <- sigma(fit_garch)
length(sigma_vals)
# Создаём xts-ряд
sigma_vals_xts <- xts(sigma_vals, order.by = index(subset_xts))
# строим график sigma для GARCH(1,1)
plot.zoo(sigma_vals_xts, main = "Условная волатильность (σ)",
col = "darkred", lwd = 2, xlab = "Дата", ylab = "σ")
grid()
# Прогнозируем sigma на 10 дней вперёд
garch_forecast <- ugarchforecast(fit_garch, n.ahead = 10)
garch_forecast
# Извлекаем прогнозируемые значения волатильности
forecast_sigma <- sigma(garch_forecast)
# Создаём xts-ряд для прогнозируемых значений
# Для упрощения можно использовать те же даты, что и в исходных данных, сдвинутые на 10 дней вперёд
forecast_dates <- seq(from = tail(index(subset_xts), 1), by = "days", length.out = 11)[-1]
forecast_sigma_xts <- xts(forecast_sigma, order.by = forecast_dates)
# Строим график прогнозируемой волатильности (σ)
plot.zoo(forecast_sigma_xts, main = "Прогноз условной волатильности (σ) на 10 дней вперёд",
col = "darkblue", lwd = 2, xlab = "Дата", ylab = "σ")
grid()
par1 = par()  #save graphic parameters
par(mfrow = c(1, 2))
# generate plots using the which argument Figure-12 1. ACF of
# standardised residuals
plot(fit_garch, which = 10)
# 2. Conditional SD (vs |returns|)
plot(fit_garch, which = 3)
# Пример с Expanding Window
# Прогнозирование с расширяющимся окном
# # Прогнозирование с фиксированным окном
# garch_roll_fixed <- ugarchroll(spec = garch_spec, data = ar.res,
#                                n.ahead = 1, forecast.length = 500,
#                                refit.every = 1, refit.window = "moving",
#                                window.size = 100)
