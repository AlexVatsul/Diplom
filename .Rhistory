plot(1:20)
install.packages("languageserver")
setwd("E:/МЕХМАТ обучение/4 семестр/очка/НИР/Diplom")
# Control + Shift + c - комментировать
# install.packages('tidyverse')
# install.packages('rio')
# install.packages('fpp3')
# install.packages('car')
# install.packages('urca')
# install.packages('ggplot2')
# install.packages('patchwork')
# install.packages('rugarch')
# install.packages('FinTS')
# install.packages('quantmod')
# install.packages('xts')
# install.packages('dplyr')
# install.packages('rugarch')
# install.packages('rmgarch')
# install.packages('PerformanceAnalytics')
# install.packages('quadprog')
# install.packages('tseries')
# install.packages('e1071')
# install.packages("forecast")
# install.packages("ggplot2")
# Загружаем необходимые библиотеки
library(quantmod)
library(xts)
library(dplyr)
library(rugarch)
library(rmgarch)
library(PerformanceAnalytics)
library(quadprog)
library(FinTS)
library(tseries)
library(e1071)
library(forecast)
library(ggplot2)
# ------------------------------
# 1. ПОДГОТОВКА ДАННЫХ
# ------------------------------
# # Загрузка CSV файлов для каждого актива (замени пути на свои)
# gazp_data <- read.csv("datasets/GAZP.csv")
# sber_data <- read.csv("datasets/SBER.csv")
# gmkn_data <- read.csv("datasets/GMKN.csv")
# mgnt_data <- read.csv("datasets/MGNT.csv")
#
# # Преобразуем данные в формат xts
# gazp_xts <- xts(gazp_data$Close, order.by = as.Date(gazp_data$Date))
# sber_xts <- xts(sber_data$Close, order.by = as.Date(sber_data$Date))
# gmkn_xts <- xts(gmkn_data$Close, order.by = as.Date(gmkn_data$Date))
# mgnt_xts <- xts(mgnt_data$Close, order.by = as.Date(mgnt_data$Date))
#
# # Отбираем данные с 2015 года по 2025 год
# start_date <- as.Date("2015-01-01")
# end_date <- as.Date("2025-12-31")
#
# gazp_xts <- window(gazp_xts, start = start_date, end = end_date)
# sber_xts <- window(sber_xts, start = start_date, end = end_date)
# gmkn_xts <- window(gmkn_xts, start = start_date, end = end_date)
# mgnt_xts <- window(mgnt_xts, start = start_date, end = end_date)
#
# # Объединяем все активы в одну таблицу
# combined_data <- merge(gazp_xts, sber_xts, gmkn_xts, mgnt_xts)
#
# # Присваиваем понятные имена колонкам
# colnames(combined_data) <- c("GAZP", "SBER", "GMKN", "MGNT")
#
# # Выводим итоговую таблицу (первые несколько строк)
# head(combined_data)
#
# # Сохраняем результат в новый CSV файл (по желанию)
# write.csv(as.data.frame(combined_data), "combined_data_2015_2025.csv")
data <- read.csv("datasets/combined_data_2015_2025.csv")
colSums(is.na(data))  # количество NA в каждом столбце
# Удалить строки с NA
data <- na.omit(data)
data$ret_gazp <- log(data$GAZP)-log(dplyr::lag(data$GAZP))
data$ret_sber <- log(data$SBER)-log(dplyr::lag(data$SBER))
data$ret_gmkn <- log(data$GMKN)-log(dplyr::lag(data$GMKN))
data$ret_mgnt <- log(data$MGNT)-log(dplyr::lag(data$MGNT))
# ------------------------------
# 2. ОДНОМЕРНЫЕ GARCH-МОДЕЛИ
# ------------------------------
ret_gazp <- data$ret_gazp[2:nrow(data)]
ret_sber <- data$ret_sber[2:nrow(data)]
ret_gmkn <- data$ret_gmkn[2:nrow(data)]
ret_mgnt <- data$ret_mgnt[2:nrow(data)]
head(data)
adf.test(ret_gazp)
adf.test(ret_sber)
adf.test(ret_gmkn)
adf.test(ret_mgnt)
plot.ts(ret_gazp)
plot.ts(ret_sber)
plot.ts(ret_gmkn)
plot.ts(ret_mgnt)
ArchTest(ret_gazp)
ArchTest(ret_sber)
ArchTest(ret_gmkn)
ArchTest(ret_mgnt)
garch(ret_gazp, grad="numerical", trace=FALSE)
garch(ret_sber, grad="numerical", trace=FALSE)
garch(ret_gmkn, grad="numerical", trace=FALSE)
garch(ret_mgnt, grad="numerical", trace=FALSE)
# 1. Найдем ARIMA модель
arima_gazp <- auto.arima(ret_gazp)
summary(arima_gazp)
# 2. Извлекаем параметры ARIMA
arima_order <- arimaorder(arima_gazp)  # Вернет вектор c(p, d, q)
# GARCH(1,1)
spec_garch_gazp <- ugarchspec(
variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),  # GARCH(1,1)
mean.model = list(armaOrder = c(0, 0)),  # ARIMA без фракционности
distribution.model = "norm"  # Можешь попробовать "std" или "ged"
)
# Подгонка модели
fit_garch_gazp <- ugarchfit(spec = spec_garch_gazp, data = ret_gazp)
show(fit_garch_gazp)
forecast_garch_gazp <- ugarchforecast(fit_garch_gazp, n.ahead = 10)
forecast_garch_gazp
# EGARCH(1,1)
spec_egarch_gazp <- ugarchspec(
variance.model = list(model = "eGARCH", garchOrder = c(1, 1)),  # GARCH(1,1)
mean.model = list(armaOrder = c(0, 0)),  # ARIMA без фракционности
distribution.model = "norm"  # Можешь попробовать "std" или "ged"
)
# Подгонка модели
fit_egarch_gazp <- ugarchfit(spec = spec_egarch_gazp, data = ret_gazp)
show(fit_egarch_gazp)
forecast_egarch_gazp <- ugarchforecast(fit_egarch_gazp, n.ahead = 10)
forecast_egarch_gazp
# 0. Извлекаем условную волатильность (σ) из GARCH модели
sigma_gazp <- forecast_garch_gazp@model$modeldata$sigma
# 2. Считаем модуль доходностей
abs_returns_gazp <- abs(ret_gazp)
# 1. Преобразуем строки с датами в Date-формат
data$Date <- as.Date(data$X)
# 2. Доходности у тебя начинаются со 2-й строки, поэтому даты тоже нужно сместить
dates_ret <- data$Date[2:nrow(data)]
# 3. Сравниваем длину
min_len <- min(length(sigma_gazp), length(ret_gazp), length(dates_ret))
# 4. Создаём датафрейм с датами
df_gazp <- data.frame(
Date = dates_ret[1:min_len],
Conditional_SD = sigma_gazp[1:min_len],
Abs_Returns = abs(ret_gazp[1:min_len])
)
# 5. Строим график
ggplot(df_gazp, aes(x = Date)) +
geom_line(aes(y = Abs_Returns, color = "|Returns|"), size = 1) +
geom_line(aes(y = Conditional_SD, color = "GARCH(1,1)"), size = 1) +
labs(title = "GAZP: Conditional SD vs |Returns|",
y = "Value", x = "Date", color = "") +
theme_minimal() +
scale_color_manual(values = c("GARCH(1,1)" = "blue", "|Returns|" = "grey"))
# 0. Извлекаем условную волатильность (σ) из GARCH модели
sigma_egazp <- forecast_egarch_gazp@model$modeldata$sigma
# 2. Считаем модуль доходностей
abs_returns_gazp <- abs(ret_gazp)
# 1. Преобразуем строки с датами в Date-формат
data$Date <- as.Date(data$X)
# 2. Доходности у тебя начинаются со 2-й строки, поэтому даты тоже нужно сместить
dates_ret <- data$Date[2:nrow(data)]
# 3. Сравниваем длину
min_len <- min(length(sigma_egazp), length(ret_gazp), length(dates_ret))
# 4. Создаём датафрейм с датами
df_gazp <- data.frame(
Date = dates_ret[1:min_len],
Conditional_SD = sigma_egazp[1:min_len],
Abs_Returns = abs(ret_gazp[1:min_len])
)
# 5. Строим график
ggplot(df_gazp, aes(x = Date)) +
geom_line(aes(y = Abs_Returns, color = "|Returns|"), size = 1) +
geom_line(aes(y = Conditional_SD, color = "EGARCH(1,1)"), size = 1) +
labs(title = "GAZP: Conditional SD vs |Returns|",
y = "Value", x = "Date", color = "") +
theme_minimal() +
scale_color_manual(values = c("EGARCH(1,1)" = "yellow", "|Returns|" = "grey"))
#
# # Спецификации (настраиваются индивидуально)
# model_garch_gazp_11 <- ugarchspec(variance.model = list(garchOrder = c(1,1)),
#                                   mean.model = list(armaOrder = c(1,0)),
#                                   distribution.model = "norm")
#
# model_garch_gazp_11_fit <- ugarchfit(model_garch_gazp_11, data = ret_gazp)
# model_garch_gazp_11_fit
#
#
#
#
# uspec_gazp <- ugarchspec(variance.model = list(model = "gjrGARCH", garchOrder = c(1,1)),
#                          mean.model = list(armaOrder = c(0,0)),
#                          distribution.model = "norm")
#
# uspec_sber <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
#                          mean.model = list(armaOrder = c(0,0)),
#                          distribution.model = "norm")
#
# uspec_gmkn <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
#                          mean.model = list(armaOrder = c(0,0)),
#                          distribution.model = "norm")
#
# uspec_mgnt <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
#                          mean.model = list(armaOrder = c(0,0)),
#                          distribution.model = "norm")
#
# # ------------------------------
# # 3. МНОГОМЕРНЫЙ DCC-GARCH
# # ------------------------------
# uspec_list <- multispec(list(uspec_gazp, uspec_sber, uspec_gmkn, uspec_mgnt))
#
# # Задаем DCC-спецификацию
# dcc_spec <- dccspec(uspec = uspec_list,
#                     dccOrder = c(1,1),
#                     distribution = "mvnorm")
#
# # Подгонка модели
# dcc_fit <- dccfit(dcc_spec, data = returns)
#
# # ------------------------------
# # 4. ОПТИМИЗАЦИЯ ПОРТФЕЛЯ
# # ------------------------------
#
# # Последняя ковариационная матрица
# last_cov <- rcov(dcc_fit)[,,dim(rcov(dcc_fit))[3]]
#
# # Оптимизация min-variance: min w' Σ w при sum(w) = 1, w >= 0
# Dmat <- 2 * last_cov
# dvec <- rep(0, 4)
# Amat <- cbind(rep(1, 4), diag(1, 4))
# bvec <- c(1, rep(0, 4))
# sol <- solve.QP(Dmat, dvec, Amat, bvec, meq = 1)
# opt_weights <- sol$solution
#
# # ------------------------------
# # 5. VaR для оптимального портфеля
# # ------------------------------
# portfolio_var_opt <- t(opt_weights) %*% last_cov %*% opt_weights
# portfolio_sd_opt <- sqrt(portfolio_var_opt)
# z_alpha <- qnorm(0.95)
# VaR_95_opt <- -z_alpha * portfolio_sd_opt
#
# print("Оптимальные веса портфеля:")
# print(round(opt_weights, 4))
# print(paste("Min-Var Портфельная волатильность:", round(portfolio_sd_opt, 6)))
# print(paste("Min-Var VaR (95%):", round(VaR_95_opt, 6)))
#
# # ------------------------------
# # 6. ИЗМЕНЕНИЯ ВОЛАТИЛЬНОСТИ (2022–2023)
# # ------------------------------
#
# # Извлекаем временной ряд условной волатильности для каждого актива
# vol_sber <- sigma(dcc_fit) [,"SBER"]
# vol_gazp <- sigma(dcc_fit) [,"GAZP"]
# vol_gmkn <- sigma(dcc_fit) [,"GMKN"]
# vol_mgnt <- sigma(dcc_fit) [,"MGNT"]
#
# # Визуализируем волатильность с 2021 по 2023 годы
# plot(vol_sber["2021::2023"], type = 'l', col = "blue", main = "Условная волатильность (SBER)", ylab = "Volatility")
# abline(v = as.Date("2022-02-24"), col = "red", lty = 2)  # геополитический шок
#
# # Аналогично можно построить графики для других активов
#
# # ------------------------------
# # 7. ВИЗУАЛИЗАЦИЯ DCC-КОРРЕЛЯЦИЙ
# # ------------------------------
# dcc_cor <- rcor(dcc_fit)
# cor_gazp_sber <- dcc_cor[1,2,]
# plot(cor_gazp_sber, type = 'l', main = "DCC: Корреляция GAZP и SBER")
